import * as AbiError from 'ox/AbiError';
import * as AbiParameters from 'ox/AbiParameters';
import { sendTransaction, } from '../../../actions/wallet/sendTransaction.js';
import { decodeErrorResult, } from '../../../utils/abi/decodeErrorResult.js';
import { encodeFunctionData, } from '../../../utils/abi/encodeFunctionData.js';
import { getContractError, } from '../../../utils/errors/getContractError.js';
import { withCache } from '../../../utils/promise/withCache.js';
import { abi, executionMode } from '../constants.js';
import { ExecuteUnsupportedError, FunctionSelectorNotRecognizedError, } from '../errors.js';
import { encodeCalls } from './execute.js';
import { supportsExecutionMode } from './supportsExecutionMode.js';
/**
 * Executes batches of call(s) using "batch of batches" mode on an [ERC-7821-compatible contract](https://eips.ethereum.org/EIPS/eip-7821).
 *
 * @example
 * ```ts
 * import { createClient, http, parseEther } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { executeBatches } from 'viem/experimental/erc7821'
 *
 * const account = privateKeyToAccount('0x...')
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const hash = await executeBatches(client, {
 *   account,
 *   batches: [
 *     {
 *       calls: [
 *         {
 *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *           value: parseEther('1'),
 *         },
 *       ],
 *     },
 *     {
 *       calls: [
 *         {
 *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
 *           value: parseEther('2'),
 *         },
 *         {
 *           data: '0xdeadbeef',
 *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *         },
 *       ],
 *     },
 *   ],
 *   to: account.address,
 * })
 * ```
 *
 * @example
 * ```ts
 * // Account Hoisting
 * import { createClient, http, parseEther } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { executeBatches } from 'viem/experimental/erc7821'
 *
 * const account = privateKeyToAccount('0x...')
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const hash = await executeBatches(client, {
 *   batches: [
 *     {
 *       calls: [
 *         {
 *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *           value: parseEther('1'),
 *         },
 *       ],
 *     },
 *     {
 *       calls: [
 *         {
 *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',
 *           value: parseEther('2'),
 *         },
 *         {
 *           data: '0xdeadbeef',
 *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *         },
 *       ],
 *     },
 *   ],
 *   to: account.address,
 * })
 * ```
 *
 * @param client - Client to use.
 * @param parameters - {@link ExecuteBatchesParameters}
 * @returns Transaction hash. {@link ExecuteBatchesReturnType}
 */
export async function executeBatches(client, parameters) {
    const { authorizationList, batches } = parameters;
    const address = authorizationList?.[0]?.contractAddress ?? parameters.address;
    const encodedBatches = AbiParameters.encode(AbiParameters.from('bytes[]'), [
        batches.map((b) => {
            const batch = b;
            return encodeCalls(batch.calls, batch.opData);
        }),
    ]);
    const supported = await withCache(() => supportsExecutionMode(client, {
        address,
        mode: 'batchOfBatches',
    }), {
        cacheKey: `supportsExecutionMode.${client.uid}.${address}.batchOfBatches`,
    });
    if (!supported)
        throw new ExecuteUnsupportedError();
    try {
        return await sendTransaction(client, {
            ...parameters,
            to: parameters.address,
            data: encodeFunctionData({
                abi,
                functionName: 'execute',
                args: [executionMode.batchOfBatches, encodedBatches],
            }),
        });
    }
    catch (e) {
        const error = e.walk((e) => 'data' in e);
        if (!error?.data)
            throw e;
        if (error.data ===
            AbiError.getSelector(AbiError.from('error FnSelectorNotRecognized()')))
            throw new FunctionSelectorNotRecognizedError();
        let matched = null;
        for (const b of parameters.batches) {
            const batch = b;
            for (const c of batch.calls) {
                const call = c;
                if (!call.abi)
                    continue;
                try {
                    const matches = Boolean(decodeErrorResult({
                        abi: call.abi,
                        data: error.data,
                    }));
                    if (!matches)
                        continue;
                    matched = call;
                }
                catch { }
            }
        }
        if (!matched)
            throw e;
        throw getContractError(error, {
            abi: matched.abi,
            address: matched.to,
            args: matched.args,
            docsPath: '/experimental/erc7821/executeBatches',
            functionName: matched.functionName,
        });
    }
}
//# sourceMappingURL=executeBatches.js.map