"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeBatches = executeBatches;
const AbiError = require("ox/AbiError");
const AbiParameters = require("ox/AbiParameters");
const sendTransaction_js_1 = require("../../../actions/wallet/sendTransaction.js");
const decodeErrorResult_js_1 = require("../../../utils/abi/decodeErrorResult.js");
const encodeFunctionData_js_1 = require("../../../utils/abi/encodeFunctionData.js");
const getContractError_js_1 = require("../../../utils/errors/getContractError.js");
const withCache_js_1 = require("../../../utils/promise/withCache.js");
const constants_js_1 = require("../constants.js");
const errors_js_1 = require("../errors.js");
const execute_js_1 = require("./execute.js");
const supportsExecutionMode_js_1 = require("./supportsExecutionMode.js");
async function executeBatches(client, parameters) {
    const { authorizationList, batches } = parameters;
    const address = authorizationList?.[0]?.contractAddress ?? parameters.address;
    const encodedBatches = AbiParameters.encode(AbiParameters.from('bytes[]'), [
        batches.map((b) => {
            const batch = b;
            return (0, execute_js_1.encodeCalls)(batch.calls, batch.opData);
        }),
    ]);
    const supported = await (0, withCache_js_1.withCache)(() => (0, supportsExecutionMode_js_1.supportsExecutionMode)(client, {
        address,
        mode: 'batchOfBatches',
    }), {
        cacheKey: `supportsExecutionMode.${client.uid}.${address}.batchOfBatches`,
    });
    if (!supported)
        throw new errors_js_1.ExecuteUnsupportedError();
    try {
        return await (0, sendTransaction_js_1.sendTransaction)(client, {
            ...parameters,
            to: parameters.address,
            data: (0, encodeFunctionData_js_1.encodeFunctionData)({
                abi: constants_js_1.abi,
                functionName: 'execute',
                args: [constants_js_1.executionMode.batchOfBatches, encodedBatches],
            }),
        });
    }
    catch (e) {
        const error = e.walk((e) => 'data' in e);
        if (!error?.data)
            throw e;
        if (error.data ===
            AbiError.getSelector(AbiError.from('error FnSelectorNotRecognized()')))
            throw new errors_js_1.FunctionSelectorNotRecognizedError();
        let matched = null;
        for (const b of parameters.batches) {
            const batch = b;
            for (const c of batch.calls) {
                const call = c;
                if (!call.abi)
                    continue;
                try {
                    const matches = Boolean((0, decodeErrorResult_js_1.decodeErrorResult)({
                        abi: call.abi,
                        data: error.data,
                    }));
                    if (!matches)
                        continue;
                    matched = call;
                }
                catch { }
            }
        }
        if (!matched)
            throw e;
        throw (0, getContractError_js_1.getContractError)(error, {
            abi: matched.abi,
            address: matched.to,
            args: matched.args,
            docsPath: '/experimental/erc7821/executeBatches',
            functionName: matched.functionName,
        });
    }
}
//# sourceMappingURL=executeBatches.js.map