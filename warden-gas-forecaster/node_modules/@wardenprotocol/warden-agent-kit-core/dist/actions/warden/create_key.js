"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateKeyAction = exports.CreateKeyInput = void 0;
exports.createKey = createKey;
const viem_1 = require("viem");
const zod_1 = require("zod");
const wardenPrecompileAbi_1 = __importDefault(require("../../utils/contracts/abi/wardenPrecompileAbi"));
const known_1 = require("../../utils/contracts/constants/known");
const chains_1 = require("../../utils/chains");
const common_1 = require("../../utils/contracts/constants/common");
const wardenContract = known_1.KNOWN_CONTRACTS[chains_1.primaryChain.id]?.WARDEN;
if (!wardenContract?.address) {
    throw new Error("Warden contract address not found");
}
const publicClient = (0, viem_1.createPublicClient)({
    chain: chains_1.primaryChain,
    transport: (0, viem_1.http)(),
});
const getSpaceById = async (spaceId) => {
    return publicClient.readContract({
        address: wardenContract.address,
        args: [spaceId],
        abi: wardenPrecompileAbi_1.default,
        functionName: "spaceById",
    });
};
const CREATE_KEY_PROMPT = `This tool should be called when a user wants to create a key. The user must specify the spaceId and keychainId and only one key can be created at a time.`;
/**
 * Input schema for create key action.
 */
exports.CreateKeyInput = zod_1.z.object({
    spaceId: zod_1.z.number(),
    keychainId: zod_1.z.number(),
});
/**
 * Creates a new key for a given space.
 *
 * @param account - The account to create the key for.
 * @param args - The input arguments for the action.
 * @returns A message containing the created key information.
 */
async function createKey(account, args) {
    try {
        const publicClient = (0, viem_1.createPublicClient)({
            chain: chains_1.primaryChain,
            transport: (0, viem_1.http)(),
        });
        const walletClient = (0, viem_1.createWalletClient)({
            account,
            chain: chains_1.primaryChain,
            transport: (0, viem_1.http)(),
        });
        if (!wardenContract?.address) {
            throw new Error("Warden contract address not found");
        }
        const space = await getSpaceById(BigInt(args.spaceId));
        const hash = await walletClient.writeContract({
            address: wardenContract.address,
            args: [
                BigInt(args.spaceId ?? 0),
                BigInt(args.keychainId ?? 0),
                1, //warden.warden.v1beta3.KeyType.KEY_TYPE_ECDSA_SECP256K1,
                space?.approveSignTemplateId ?? 0,
                space?.rejectSignTemplateId ?? 0,
                [],
                BigInt(space?.nonce ?? 0),
                BigInt(0),
                common_1.DEFAULT_EXPRESSION, // TODO: replace with approveTemplate
                common_1.DEFAULT_EXPRESSION, // TODO: replace with rejectTemplate
            ],
            abi: wardenPrecompileAbi_1.default,
            functionName: "newKeyRequest",
        });
        const receipt = await publicClient.waitForTransactionReceipt({
            hash,
        });
        if (receipt.status === "success") {
            return `Successfully created key for space ${args.spaceId}. Transaction hash: ${receipt.transactionHash}`;
        }
        else {
            throw new Error("Transaction failed");
        }
    }
    catch (error) {
        return `Error creating key: ${error}`;
    }
}
/**
 * Create key action.
 */
class CreateKeyAction {
    constructor() {
        this.name = "create_key";
        this.description = CREATE_KEY_PROMPT;
        this.schema = exports.CreateKeyInput;
        this.function = createKey;
    }
}
exports.CreateKeyAction = CreateKeyAction;
