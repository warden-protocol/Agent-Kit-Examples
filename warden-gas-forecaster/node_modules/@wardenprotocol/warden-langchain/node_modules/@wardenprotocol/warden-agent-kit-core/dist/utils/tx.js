"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNewKeyTransaction = exports.createNewSpaceTransaction = exports.createSendTransaction = void 0;
const viem_1 = require("viem");
const utils_1 = require("viem/utils");
const accounts_1 = require("viem/accounts");
const erc20Abi_1 = __importDefault(require("./contracts/abi/erc20Abi"));
const wardenPrecompileAbi_1 = __importDefault(require("./contracts/abi/wardenPrecompileAbi"));
const known_1 = require("./contracts/constants/known");
const chains_1 = require("./chains");
const ETH_ANALYZER = "0xade4a5f5803a439835c636395a8d648dee57b2fc90d98dc17fa887159b69638b"; // TODO: move to constants or env
const wardenContract = known_1.KNOWN_CONTRACTS[chains_1.primaryChain.id]?.WARDEN;
function prepareEth(chain, account_, parameters) {
    const { accessList, 
    // authorizationList,
    blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
    if (typeof account_ === "undefined")
        throw new Error("account not found");
    const account = account_ ? (0, accounts_1.parseAccount)(account_) : null;
    const to = rest.to;
    (0, viem_1.assertRequest)({ ...parameters, chain, account });
    if (account?.type === "json-rpc" || account === null) {
        const chainId = chain?.id;
        if (!chainId)
            throw new Error("chainId not found");
        const chainFormat = chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || viem_1.formatTransactionRequest;
        const request = {
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, utils_1.extract)(rest, { format: chainFormat }),
            accessList,
            // authorizationList,
            blobs,
            chainId,
            data,
            from: account?.address,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        };
        return { request, format };
    }
    throw new Error(`unsupported account type: ${account?.type}`);
}
const createSendTransaction = (params) => {
    const data = params.token
        ? (0, viem_1.encodeFunctionData)({
            abi: erc20Abi_1.default,
            functionName: "transfer",
            args: [params.to, params.amount],
        })
        : undefined;
    return prepareEth(params.chain, params.from, {
        data,
        to: params.token ?? params.to,
        value: params.token ? BigInt(0) : params.amount,
    });
};
exports.createSendTransaction = createSendTransaction;
const createNewSpaceTransaction = (params) => {
    return prepareEth(params.chain, params.from, {
        data: (0, viem_1.encodeFunctionData)({
            abi: wardenPrecompileAbi_1.default,
            functionName: "newSpace",
            args: [BigInt(0), BigInt(0), BigInt(0), BigInt(0), []],
        }),
        to: wardenContract?.address,
        value: BigInt(0),
    });
};
exports.createNewSpaceTransaction = createNewSpaceTransaction;
const createNewKeyTransaction = (params) => {
    return prepareEth(params.chain, params.from, {
        data: (0, viem_1.encodeFunctionData)({
            abi: wardenPrecompileAbi_1.default,
            functionName: "newKeyRequest",
            args: [
                params.spaceId,
                params.keychainId,
                params.keyType,
                params.signTemplateId,
                params.rejectTemplateId,
                [],
                params.nonce,
                BigInt(0),
                params.expectedApproveExpression,
                params.expectedRejectExpression,
            ],
        }),
        to: wardenContract?.address,
        value: BigInt(0),
    });
};
exports.createNewKeyTransaction = createNewKeyTransaction;
// export const createNewSignRequestTransaction = (params: {
//     chain: Chain;
//     from: `0x${string}`;
//     keyId: bigint;
//     nonce: bigint;
//     expectedApproveExpression: string;
//     expectedRejectExpression: string;
//     inner: TransactionSerializable;
// }) => {
//     return prepareEth(params.chain, params.from, {
//         data: encodeFunctionData({
//             abi: wardenPrecompileAbi,
//             functionName: "newSignRequest",
//             args: [
//                 params.keyId,
//                 serializeTransaction(params.inner),
//                 [ETH_ANALYZER],
//                 "0x",
//                 [],
//                 params.nonce,
//                 BigInt(0),
//                 params.expectedApproveExpression,
//                 params.expectedRejectExpression,
//             ],
//         }),
//         to: wardenContract?.address,
//         value: BigInt(0),
//     });
// };
